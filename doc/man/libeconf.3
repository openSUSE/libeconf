.TH "libeconf" 3 "Thu Apr 8 2021" "Version 0.4.0" "libeconf" \" -*- nroff -*-
.ad l
.nh
.SH NAME
include/libeconf.h \- Public API for the econf library\&.
.br
include/libeconf_ext.h \- Public extended API for the econf library\&.

.SH SYNOPSIS
.br
.PP
\fC#include <stdbool\&.h>\fP
.br
\fC#include <stdint\&.h>\fP
.br
\fC#include <stdlib\&.h>\fP
.br


.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef enum \fBeconf_err\fP \fBeconf_err\fP"
.br
.ti -1c
.RI "typedef struct \fBeconf_file\fP \fBeconf_file\fP"
.br
.ti -1c
.RI "typedef struct \fBeconf_ext_value\fP \fBeconf_ext_value\fP"
.br
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBeconf_err\fP { \fBECONF_SUCCESS\fP = 0, \fBECONF_ERROR\fP = 1, \fBECONF_NOMEM\fP = 2, \fBECONF_NOFILE\fP = 3, \fBECONF_NOGROUP\fP = 4, \fBECONF_NOKEY\fP = 5, \fBECONF_EMPTYKEY\fP = 6, \fBECONF_WRITEERROR\fP = 7, \fBECONF_PARSE_ERROR\fP = 8, \fBECONF_MISSING_BRACKET\fP = 9, \fBECONF_MISSING_DELIMITER\fP = 10, \fBECONF_EMPTY_SECTION_NAME\fP = 11, \fBECONF_TEXT_AFTER_SECTION\fP = 12 }"
.br
.RI "libeconf error codes "
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBeconf_err\fP \fBeconf_readFile\fP (\fBeconf_file\fP **result, const char *file_name, const char *delim, const char *comment)"
.br
.RI "Process the file of the given file_name and save its contents into key_file object\&. "
.ti -1c
.RI "\fBeconf_err\fP \fBeconf_mergeFiles\fP (\fBeconf_file\fP **merged_file, \fBeconf_file\fP *usr_file, \fBeconf_file\fP *etc_file)"
.br
.RI "Merge the contents of two key_files objects\&. "
.ti -1c
.RI "\fBeconf_err\fP \fBeconf_readDirs\fP (\fBeconf_file\fP **key_file, const char *usr_conf_dir, const char *etc_conf_dir, const char *project_name, const char *config_suffix, const char *delim, const char *comment)"
.br
.RI "Evaluating the content of a given configuration file by reading all needed/available files in two different directories (normally in /usr/etc and /etc)\&. "
.ti -1c
.RI "\fBeconf_err\fP \fBeconf_newKeyFile\fP (\fBeconf_file\fP **result, char delimiter, char comment)"
.br
.RI "Create a new econf_file object\&. "
.ti -1c
.RI "\fBeconf_err\fP \fBeconf_newIniFile\fP (\fBeconf_file\fP **result)"
.br
.RI "Create a new econf_file object in IniFile format\&. "
.ti -1c
.RI "\fBeconf_err\fP \fBeconf_writeFile\fP (\fBeconf_file\fP *key_file, const char *save_to_dir, const char *file_name)"
.br
.RI "Write content of a econf_file struct to specified location\&. "
.ti -1c
.RI "\fBeconf_err\fP \fBeconf_getGroups\fP (\fBeconf_file\fP *kf, size_t *length, char ***groups)"
.br
.RI "Evaluating all group entries\&. "
.ti -1c
.RI "\fBeconf_err\fP \fBeconf_getKeys\fP (\fBeconf_file\fP *kf, const char *group, size_t *length, char ***keys)"
.br
.RI "Evaluating all keys\&. "
.ti -1c
.RI "\fBeconf_err\fP \fBeconf_getIntValue\fP (\fBeconf_file\fP *kf, const char *group, const char *key, int32_t *result)"
.br
.RI "Evaluating int32 value for given group/key\&. "
.ti -1c
.RI "\fBeconf_err\fP \fBeconf_getInt64Value\fP (\fBeconf_file\fP *kf, const char *group, const char *key, int64_t *result)"
.br
.RI "Evaluating int64 value for given group/key\&. "
.ti -1c
.RI "\fBeconf_err\fP \fBeconf_getUIntValue\fP (\fBeconf_file\fP *kf, const char *group, const char *key, uint32_t *result)"
.br
.RI "Evaluating uint32 value for given group/key\&. "
.ti -1c
.RI "\fBeconf_err\fP \fBeconf_getUInt64Value\fP (\fBeconf_file\fP *kf, const char *group, const char *key, uint64_t *result)"
.br
.RI "Evaluating uint64 value for given group/key\&. "
.ti -1c
.RI "\fBeconf_err\fP \fBeconf_getFloatValue\fP (\fBeconf_file\fP *kf, const char *group, const char *key, float *result)"
.br
.RI "Evaluating float value for given group/key\&. "
.ti -1c
.RI "\fBeconf_err\fP \fBeconf_getDoubleValue\fP (\fBeconf_file\fP *kf, const char *group, const char *key, double *result)"
.br
.RI "Evaluating double value for given group/key\&. "
.ti -1c
.RI "\fBeconf_err\fP \fBeconf_getStringValue\fP (\fBeconf_file\fP *kf, const char *group, const char *key, char **result)"
.br
.RI "Evaluating string value for given group/key\&. "
.ti -1c
.RI "\fBeconf_err\fP \fBeconf_getBoolValue\fP (\fBeconf_file\fP *kf, const char *group, const char *key, bool *result)"
.br
.RI "Evaluating bool value for given group/key\&. "
.ti -1c
.RI "\fBeconf_err\fP \fBeconf_getIntValueDef\fP (\fBeconf_file\fP *kf, const char *group, const char *key, int32_t *result, int32_t def)"
.br
.RI "Evaluating int32 value for given group/key\&. "
.ti -1c
.RI "\fBeconf_err\fP \fBeconf_getInt64ValueDef\fP (\fBeconf_file\fP *kf, const char *group, const char *key, int64_t *result, int64_t def)"
.br
.RI "Evaluating int64 value for given group/key\&. "
.ti -1c
.RI "\fBeconf_err\fP \fBeconf_getUIntValueDef\fP (\fBeconf_file\fP *kf, const char *group, const char *key, uint32_t *result, uint32_t def)"
.br
.RI "Evaluating uint32 value for given group/key\&. "
.ti -1c
.RI "\fBeconf_err\fP \fBeconf_getUInt64ValueDef\fP (\fBeconf_file\fP *kf, const char *group, const char *key, uint64_t *result, uint64_t def)"
.br
.RI "Evaluating uint64 value for given group/key\&. "
.ti -1c
.RI "\fBeconf_err\fP \fBeconf_getFloatValueDef\fP (\fBeconf_file\fP *kf, const char *group, const char *key, float *result, float def)"
.br
.RI "Evaluating float value for given group/key\&. "
.ti -1c
.RI "\fBeconf_err\fP \fBeconf_getDoubleValueDef\fP (\fBeconf_file\fP *kf, const char *group, const char *key, double *result, double def)"
.br
.RI "Evaluating double value for given group/key\&. "
.ti -1c
.RI "\fBeconf_err\fP \fBeconf_getStringValueDef\fP (\fBeconf_file\fP *kf, const char *group, const char *key, char **result, char *def)"
.br
.RI "Evaluating string value for given group/key\&. "
.ti -1c
.RI "\fBeconf_err\fP \fBeconf_getBoolValueDef\fP (\fBeconf_file\fP *kf, const char *group, const char *key, bool *result, bool def)"
.br
.RI "Evaluating bool value for given group/key\&. "
.ti -1c
.RI "\fBeconf_err\fP \fBeconf_setIntValue\fP (\fBeconf_file\fP *kf, const char *group, const char *key, int32_t value)"
.br
.RI "Set int32 value for given group/key\&. "
.ti -1c
.RI "\fBeconf_err\fP \fBeconf_setInt64Value\fP (\fBeconf_file\fP *kf, const char *group, const char *key, int64_t value)"
.br
.RI "Set int64 value for given group/key\&. "
.ti -1c
.RI "\fBeconf_err\fP \fBeconf_setUIntValue\fP (\fBeconf_file\fP *kf, const char *group, const char *key, uint32_t value)"
.br
.RI "Set uint32 value for given group/key\&. "
.ti -1c
.RI "\fBeconf_err\fP \fBeconf_setUInt64Value\fP (\fBeconf_file\fP *kf, const char *group, const char *key, uint64_t value)"
.br
.RI "Set uint64 value for given group/key\&. "
.ti -1c
.RI "\fBeconf_err\fP \fBeconf_setFloatValue\fP (\fBeconf_file\fP *kf, const char *group, const char *key, float value)"
.br
.RI "Set float value for given group/key\&. "
.ti -1c
.RI "\fBeconf_err\fP \fBeconf_setDoubleValue\fP (\fBeconf_file\fP *kf, const char *group, const char *key, double value)"
.br
.RI "Set double value for given group/key\&. "
.ti -1c
.RI "\fBeconf_err\fP \fBeconf_setStringValue\fP (\fBeconf_file\fP *kf, const char *group, const char *key, const char *value)"
.br
.RI "Set string value for given group/key\&. "
.ti -1c
.RI "\fBeconf_err\fP \fBeconf_setBoolValue\fP (\fBeconf_file\fP *kf, const char *group, const char *key, const char *value)"
.br
.RI "Set bool value for given group/key\&. "
.ti -1c
.RI "const char * \fBeconf_errString\fP (const \fBeconf_err\fP error)"
.br
.RI "Convert an econf_err type to a string\&. "
.ti -1c
.RI "void \fBeconf_errLocation\fP (char **filename, uint64_t *line_nr)"
.br
.RI "Info about where the error has happened\&. "
.ti -1c
.RI "void \fBeconf_freeArray\fP (char **array)"
.br
.RI "Free an array of type char** created by \fBeconf_getGroups()\fP or \fBeconf_getKeys()\fP\&. "
.ti -1c
.RI "void \fBeconf_freeFile\fP (\fBeconf_file\fP *key_file)"
.br
.RI "Free memory allocated by e\&.g\&. "
.in -1c
.RI "\fBeconf_err\fP \fBeconf_getExtValue\fP (\fBeconf_file\fP *kf, const char *group, const char *key, \fBeconf_ext_value\fP **result)"
.in +1c
.RI "Evaluating more information for given group/key\&. "
.ti -1c
.RI "void \fBeconf_freeExtValue\fP (\fBeconf_ext_value\fP *to_free)"
.br
.RI "Free an complete \fBeconf_ext_value\fP struct\&. "
.in -1c
.SH "Detailed Description"
.PP 
Public API for the econf library\&. 


.PP
Definition in file \fBlibeconf\&.h\fP\& and \fBlibeconf_ext\&.h\fP\&.

.SH "Typedef Documentation"
.PP
.SS "typedef struct \fBeconf_file\fP \fBeconf_file\fP"

.PP
Container which includes all information about the configuration file(s)\&.
.SS "typedef struct \fBeconf_ext_value\fP \fBeconf_ext_value\fP"

.PP
.in +1c
.ti -1c
.RI "char ** \fBvalues\fP"
.br
.RI "Values of a given key in form of an string array\&. "
.ti -1c
.RI "char * \fBfile\fP"
.br
.RI "Path of the configuration file where this value has been read\&. "
.ti -1c
.RI "uint64_t \fBline_number\fP"
.br
.RI "Line number of the configuration key/value\&. "
.ti -1c
.RI "char * \fBcomment_before_key\fP"
.br
.RI "Comment before the key/value entry\&. "
.ti -1c
.RI "char * \fBcomment_after_value\fP"
.br
.RI "Comment after the value entry\&. "
.in -1c


.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fBeconf_err\fP"

.PP
libeconf error codes 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIECONF_SUCCESS \fP\fP
General purpose success code\&. 
.TP
\fB\fIECONF_ERROR \fP\fP
Generic Error\&. 
.TP
\fB\fIECONF_NOMEM \fP\fP
Out of memory\&. 
.TP
\fB\fIECONF_NOFILE \fP\fP
Config file not found\&. 
.TP
\fB\fIECONF_NOGROUP \fP\fP
Group not found\&. 
.TP
\fB\fIECONF_NOKEY \fP\fP
Key not found\&. 
.TP
\fB\fIECONF_EMPTYKEY \fP\fP
Key has empty value\&. 
.TP
\fB\fIECONF_WRITEERROR \fP\fP
Error creating or writing to a file\&. 
.TP
\fB\fIECONF_PARSE_ERROR \fP\fP
General syntax error in input file\&. 
.TP
\fB\fIECONF_MISSING_BRACKET \fP\fP
Missing closing section bracket\&. 
.TP
\fB\fIECONF_MISSING_DELIMITER \fP\fP
Missing delimiter\&. 
.TP
\fB\fIECONF_EMPTY_SECTION_NAME \fP\fP
Empty section name\&. 
.TP
\fB\fIECONF_TEXT_AFTER_SECTION \fP\fP
Text after section\&. 
.PP
Definition at line 40 of file libeconf\&.h\&.
.SH "Function Documentation"
.PP 
.SS "\fBeconf_err\fP econf_readFile (\fBeconf_file\fP ** result, const char * file_name, const char * delim, const char * comment)"

.PP
Process the file of the given file_name and save its contents into key_file object\&. 
.PP
\fBParameters:\fP
.RS 4
\fIresult\fP content of parsed file 
.br
\fIfile_name\fP absolute path of parsed file 
.br
\fIdelim\fP delimiters of key/value e\&.g\&. '\\t =' 
.br
\fIcomment\fP array of characters which define the start of a comment 
.RE
.PP
\fBReturns:\fP
.RS 4
econf_err ECONF_SUCCESS or error code
.RE
.PP
Usage: 
.PP
.nf
#include "libeconf\&.h"

econf_file *key_file = NULL;
econf_err error;

error = econf_readFile (&key_file, "/etc/test\&.conf", "=", "#");

econf_free (key_file);

.fi
.PP
.PP
Default behaviour if entries have the same name in one file: The first hit will be returned\&. Further entries will be ignored\&. This can be changed by setting the environment variable ECONF_JOIN_SAME_ENTRIES\&. In that case entries with the same name will be joined to one single entry\&. 
.SS "\fBeconf_err\fP econf_mergeFiles (\fBeconf_file\fP ** merged_file, \fBeconf_file\fP * usr_file, \fBeconf_file\fP * etc_file)"

.PP
Merge the contents of two key_files objects\&. Entries in etc_file will be prefered\&.
.PP
\fBParameters:\fP
.RS 4
\fImerged_file\fP merged data 
.br
\fIusr_file\fP First data block which has to be merged\&. 
.br
\fIetc_file\fP Second data block which has to be merged\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
econf_err ECONF_SUCCESS or error code
.RE
.PP
Usage: 
.PP
.nf
#include "libeconf\&.h"

econf_file *key_file_1 = NULL, *key_file_2 = NULL, *key_file_ret = NULL
econf_err error;

error = econf_readFile (&key_file1, "/usr/etc/test\&.conf", "=", "#");
error = econf_readFile (&key_file2, /etc/test\&.conf", "=", "#");
error = econf_mergeFiles (&key_file_ret, key_file_1, key_file_2);

econf_free (key_file_ret);
econf_free (key_file_1);
econf_free (key_file_2);

.fi
.PP
 
.SS "\fBeconf_err\fP econf_readDirs (\fBeconf_file\fP ** key_file, const char * usr_conf_dir, const char * etc_conf_dir, const char * project_name, const char * config_suffix, const char * delim, const char * comment)"

.PP
Evaluating the content of a given configuration file by reading all needed/available files in two different directories (normally in /usr/etc and /etc)\&. 
.PP
\fBParameters:\fP
.RS 4
\fIkey_file\fP content of parsed file(s) 
.br
\fIusr_conf_dir\fP absolute path of the first directory (normally '/usr/etc') 
.br
\fIetc_conf_dir\fP absolute path of the second directory (normally '/etc') 
.br
\fIproject_name\fP basename of the configuration file 
.br
\fIconfig_suffix\fP suffix of the configuration file\&. Can also be NULL\&. 
.br
\fIdelim\fP delimiters of key/value e\&.g\&. '\\t =' 
.br
\fIcomment\fP array of characters which define the start of a comment 
.RE
.PP
\fBReturns:\fP
.RS 4
econf_err ECONF_SUCCESS or error code
.RE
.PP
Example: Reading content of example\&.conf in /usr/etc and /etc directory\&. 
.PP
.nf
#include "libeconf\&.h"

econf_file *key_file = NULL;
econf_err error;

error = econf_readDirs (&key_file,
                        "/usr/etc",
                        "/etc",
                        "example",
                        "conf",
                        "=", "#");

econf_free (key_file);

.fi
.PP
 
.SS "\fBeconf_err\fP econf_newKeyFile (\fBeconf_file\fP ** result, char delimiter, char comment)"

.PP
Create a new econf_file object\&. 
.PP
\fBParameters:\fP
.RS 4
\fIresult\fP Pointer to the allocated econf_file object\&. 
.br
\fIdelimiter\fP delimiter of key/value e\&.g\&. '=' 
.br
\fIcomment\fP Character which defines the start of a comment\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
econf_err ECONF_SUCCESS or error code
.RE
.PP
Default behaviour if entries have the same name in one file: The first hit will be returned\&. Further entries will be ignored\&. This can be changed by setting the environment variable ECONF_JOIN_SAME_ENTRIES\&. In that case entries with the same name will be joined to one single entry\&. 
.SS "\fBeconf_err\fP econf_newIniFile (\fBeconf_file\fP ** result)"

.PP
Create a new econf_file object in IniFile format\&. So the delimiter will be '=' and comments are beginning with '#'\&.
.PP
\fBParameters:\fP
.RS 4
\fIresult\fP Pointer to the allocated econf_file object\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
econf_err ECONF_SUCCESS or error code 
.RE
.PP

.SS "\fBeconf_err\fP econf_writeFile (\fBeconf_file\fP * key_file, const char * save_to_dir, const char * file_name)"

.PP
Write content of a econf_file struct to specified location\&. 
.PP
\fBParameters:\fP
.RS 4
\fIkey_file\fP Data which has to be written\&. 
.br
\fIsave_to_dir\fP Directory into which the file has to be written\&. 
.br
\fIfile_name\fP filename (with suffix) 
.RE
.PP
\fBReturns:\fP
.RS 4
econf_err ECONF_SUCCESS or error code 
.RE
.PP

.SS "\fBeconf_err\fP econf_getGroups (\fBeconf_file\fP * kf, size_t * length, char *** groups)"

.PP
Evaluating all group entries\&. 
.PP
\fBParameters:\fP
.RS 4
\fIkf\fP given/parsed data 
.br
\fIlength\fP Length of the returned group array\&. 
.br
\fIgroups\fP String array of evaluated groups\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
econf_err ECONF_SUCCESS or error code 
.RE
.PP

.SS "\fBeconf_err\fP econf_getKeys (\fBeconf_file\fP * kf, const char * group, size_t * length, char *** keys)"

.PP
Evaluating all keys\&. 
.PP
\fBParameters:\fP
.RS 4
\fIkf\fP given/parsed data 
.br
\fIgroup\fP Group name for which the keys have to be evaluated or NULL for all keys\&. 
.br
\fIlength\fP Length of the returned key array\&. 
.br
\fIkeys\fP String array of evaluated keys\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
econf_err ECONF_SUCCESS or error code 
.RE
.PP

.SS "\fBeconf_err\fP econf_getIntValue (\fBeconf_file\fP * kf, const char * group, const char * key, int32_t * result)"

.PP
Evaluating int32 value for given group/key\&. 
.PP
\fBParameters:\fP
.RS 4
\fIkf\fP given/parsed data 
.br
\fIgroup\fP Desired group or NULL if there is no group defined\&. 
.br
\fIkey\fP Key for which the value is requested\&. 
.br
\fIresult\fP determined value 
.RE
.PP
\fBReturns:\fP
.RS 4
econf_err ECONF_SUCCESS or error code 
.RE
.PP

.SS "\fBeconf_err\fP econf_getInt64Value (\fBeconf_file\fP * kf, const char * group, const char * key, int64_t * result)"

.PP
Evaluating int64 value for given group/key\&. 
.PP
\fBParameters:\fP
.RS 4
\fIkf\fP given/parsed data 
.br
\fIgroup\fP Desired group or NULL if there is no group defined\&. 
.br
\fIkey\fP Key for which the value is requested\&. 
.br
\fIresult\fP determined value 
.RE
.PP
\fBReturns:\fP
.RS 4
econf_err ECONF_SUCCESS or error code 
.RE
.PP

.SS "\fBeconf_err\fP econf_getUIntValue (\fBeconf_file\fP * kf, const char * group, const char * key, uint32_t * result)"

.PP
Evaluating uint32 value for given group/key\&. 
.PP
\fBParameters:\fP
.RS 4
\fIkf\fP given/parsed data 
.br
\fIgroup\fP Desired group or NULL if there is no group defined\&. 
.br
\fIkey\fP Key for which the value is requested\&. 
.br
\fIresult\fP determined value 
.RE
.PP
\fBReturns:\fP
.RS 4
econf_err ECONF_SUCCESS or error code 
.RE
.PP

.SS "\fBeconf_err\fP econf_getUInt64Value (\fBeconf_file\fP * kf, const char * group, const char * key, uint64_t * result)"

.PP
Evaluating uint64 value for given group/key\&. 
.PP
\fBParameters:\fP
.RS 4
\fIkf\fP given/parsed data 
.br
\fIgroup\fP Desired group or NULL if there is no group defined\&. 
.br
\fIkey\fP Key for which the value is requested\&. 
.br
\fIresult\fP determined value 
.RE
.PP
\fBReturns:\fP
.RS 4
econf_err ECONF_SUCCESS or error code 
.RE
.PP

.SS "\fBeconf_err\fP econf_getFloatValue (\fBeconf_file\fP * kf, const char * group, const char * key, float * result)"

.PP
Evaluating float value for given group/key\&. 
.PP
\fBParameters:\fP
.RS 4
\fIkf\fP given/parsed data 
.br
\fIgroup\fP Desired group or NULL if there is no group defined\&. 
.br
\fIkey\fP Key for which the value is requested\&. 
.br
\fIresult\fP determined value 
.RE
.PP
\fBReturns:\fP
.RS 4
econf_err ECONF_SUCCESS or error code 
.RE
.PP

.SS "\fBeconf_err\fP econf_getDoubleValue (\fBeconf_file\fP * kf, const char * group, const char * key, double * result)"

.PP
Evaluating double value for given group/key\&. 
.PP
\fBParameters:\fP
.RS 4
\fIkf\fP given/parsed data 
.br
\fIgroup\fP Desired group or NULL if there is no group defined\&. 
.br
\fIkey\fP Key for which the value is requested\&. 
.br
\fIresult\fP determined value 
.RE
.PP
\fBReturns:\fP
.RS 4
econf_err ECONF_SUCCESS or error code 
.RE
.PP

.SS "\fBeconf_err\fP econf_getStringValue (\fBeconf_file\fP * kf, const char * group, const char * key, char ** result)"

.PP
Evaluating string value for given group/key\&. 
.PP
\fBParameters:\fP
.RS 4
\fIkf\fP given/parsed data 
.br
\fIgroup\fP Desired group or NULL if there is no group defined\&. 
.br
\fIkey\fP Key for which the value is requested\&. 
.br
\fIresult\fP A newly allocated string or NULL in error case\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
econf_err ECONF_SUCCESS or error code 
.RE
.PP

.SS "\fBeconf_err\fP econf_getBoolValue (\fBeconf_file\fP * kf, const char * group, const char * key, bool * result)"

.PP
Evaluating bool value for given group/key\&. 
.PP
\fBParameters:\fP
.RS 4
\fIkf\fP given/parsed data 
.br
\fIgroup\fP Desired group or NULL if there is no group defined\&. 
.br
\fIkey\fP Key for which the value is requested\&. 
.br
\fIresult\fP determined value 
.RE
.PP
\fBReturns:\fP
.RS 4
econf_err ECONF_SUCCESS or error code 
.RE
.PP

.SS "\fBeconf_err\fP econf_getIntValueDef (\fBeconf_file\fP * kf, const char * group, const char * key, int32_t * result, int32_t def)"

.PP
Evaluating int32 value for given group/key\&. If key is not found, the default value is returned and error is ECONF_NOKEY\&.
.PP
\fBParameters:\fP
.RS 4
\fIkf\fP given/parsed data 
.br
\fIgroup\fP Desired group or NULL if there is no group defined\&. 
.br
\fIkey\fP Key for which the value is requested\&. 
.br
\fIresult\fP determined value 
.br
\fIdef\fP Default value if the value has not been found\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
econf_err ECONF_SUCCESS or error code 
.RE
.PP

.SS "\fBeconf_err\fP econf_getInt64ValueDef (\fBeconf_file\fP * kf, const char * group, const char * key, int64_t * result, int64_t def)"

.PP
Evaluating int64 value for given group/key\&. If key is not found, the default value is returned and error is ECONF_NOKEY\&.
.PP
\fBParameters:\fP
.RS 4
\fIkf\fP given/parsed data 
.br
\fIgroup\fP Desired group or NULL if there is no group defined\&. 
.br
\fIkey\fP Key for which the value is requested\&. 
.br
\fIresult\fP determined value 
.br
\fIdef\fP Default value if the value has not been found\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
econf_err ECONF_SUCCESS or error code 
.RE
.PP

.SS "\fBeconf_err\fP econf_getUIntValueDef (\fBeconf_file\fP * kf, const char * group, const char * key, uint32_t * result, uint32_t def)"

.PP
Evaluating uint32 value for given group/key\&. If key is not found, the default value is returned and error is ECONF_NOKEY\&.
.PP
\fBParameters:\fP
.RS 4
\fIkf\fP given/parsed data 
.br
\fIgroup\fP Desired group or NULL if there is no group defined\&. 
.br
\fIkey\fP Key for which the value is requested\&. 
.br
\fIresult\fP determined value 
.br
\fIdef\fP Default value if the value has not been found\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
econf_err ECONF_SUCCESS or error code 
.RE
.PP

.SS "\fBeconf_err\fP econf_getUInt64ValueDef (\fBeconf_file\fP * kf, const char * group, const char * key, uint64_t * result, uint64_t def)"

.PP
Evaluating uint64 value for given group/key\&. If key is not found, the default value is returned and error is ECONF_NOKEY\&.
.PP
\fBParameters:\fP
.RS 4
\fIkf\fP given/parsed data 
.br
\fIgroup\fP Desired group or NULL if there is no group defined\&. 
.br
\fIkey\fP Key for which the value is requested\&. 
.br
\fIresult\fP determined value 
.br
\fIdef\fP Default value if the value has not been found\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
econf_err ECONF_SUCCESS or error code 
.RE
.PP

.SS "\fBeconf_err\fP econf_getFloatValueDef (\fBeconf_file\fP * kf, const char * group, const char * key, float * result, float def)"

.PP
Evaluating float value for given group/key\&. If key is not found, the default value is returned and error is ECONF_NOKEY\&.
.PP
\fBParameters:\fP
.RS 4
\fIkf\fP given/parsed data 
.br
\fIgroup\fP Desired group or NULL if there is no group defined\&. 
.br
\fIkey\fP Key for which the value is requested\&. 
.br
\fIresult\fP determined value 
.br
\fIdef\fP Default value if the value has not been found\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
econf_err ECONF_SUCCESS or error code 
.RE
.PP

.SS "\fBeconf_err\fP econf_getDoubleValueDef (\fBeconf_file\fP * kf, const char * group, const char * key, double * result, double def)"

.PP
Evaluating double value for given group/key\&. If key is not found, the default value is returned and error is ECONF_NOKEY\&.
.PP
\fBParameters:\fP
.RS 4
\fIkf\fP given/parsed data 
.br
\fIgroup\fP Desired group or NULL if there is no group defined\&. 
.br
\fIkey\fP Key for which the value is requested\&. 
.br
\fIresult\fP determined value 
.br
\fIdef\fP Default value if the value has not been found\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
econf_err ECONF_SUCCESS or error code 
.RE
.PP

.SS "\fBeconf_err\fP econf_getStringValueDef (\fBeconf_file\fP * kf, const char * group, const char * key, char ** result, char * def)"

.PP
Evaluating string value for given group/key\&. If key is not found, the default value is returned and error is ECONF_NOKEY\&.
.PP
\fBParameters:\fP
.RS 4
\fIkf\fP given/parsed data 
.br
\fIgroup\fP Desired group or NULL if there is no group defined\&. 
.br
\fIkey\fP Key for which the value is requested\&. 
.br
\fIresult\fP Returns a newly allocated string, even if 'default' is returned\&. 
.br
\fIdef\fP Default value if the value has not been found\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
econf_err ECONF_SUCCESS or error code 
.RE
.PP

.SS "\fBeconf_err\fP econf_getBoolValueDef (\fBeconf_file\fP * kf, const char * group, const char * key, bool * result, bool def)"

.PP
Evaluating bool value for given group/key\&. If key is not found, the default value is returned and error is ECONF_NOKEY\&.
.PP
\fBParameters:\fP
.RS 4
\fIkf\fP given/parsed data 
.br
\fIgroup\fP Desired group or NULL if there is no group defined\&. 
.br
\fIkey\fP Key for which the value is requested\&. 
.br
\fIresult\fP determined value 
.br
\fIdef\fP Default value if the value has not been found\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
econf_err ECONF_SUCCESS or error code 
.RE
.PP

.SS "\fBeconf_err\fP econf_setIntValue (\fBeconf_file\fP * kf, const char * group, const char * key, int32_t value)"

.PP
Set int32 value for given group/key\&. 
.PP
\fBParameters:\fP
.RS 4
\fIkf\fP given/parsed data 
.br
\fIgroup\fP Desired group or NULL if there is no group defined\&. 
.br
\fIkey\fP Key for which the value has to be set\&. 
.br
\fIvalue\fP Value which has to be set\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
econf_err ECONF_SUCCESS or error code 
.RE
.PP

.SS "\fBeconf_err\fP econf_setInt64Value (\fBeconf_file\fP * kf, const char * group, const char * key, int64_t value)"

.PP
Set int64 value for given group/key\&. 
.PP
\fBParameters:\fP
.RS 4
\fIkf\fP given/parsed data 
.br
\fIgroup\fP Desired group or NULL if there is no group defined\&. 
.br
\fIkey\fP Key for which the value has to be set\&. 
.br
\fIvalue\fP Value which has to be set\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
econf_err ECONF_SUCCESS or error code 
.RE
.PP

.SS "\fBeconf_err\fP econf_setUIntValue (\fBeconf_file\fP * kf, const char * group, const char * key, uint32_t value)"

.PP
Set uint32 value for given group/key\&. 
.PP
\fBParameters:\fP
.RS 4
\fIkf\fP given/parsed data 
.br
\fIgroup\fP Desired group or NULL if there is no group defined\&. 
.br
\fIkey\fP Key for which the value has to be set\&. 
.br
\fIvalue\fP Value which has to be set\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
econf_err ECONF_SUCCESS or error code 
.RE
.PP

.SS "\fBeconf_err\fP econf_setUInt64Value (\fBeconf_file\fP * kf, const char * group, const char * key, uint64_t value)"

.PP
Set uint64 value for given group/key\&. 
.PP
\fBParameters:\fP
.RS 4
\fIkf\fP given/parsed data 
.br
\fIgroup\fP Desired group or NULL if there is no group defined\&. 
.br
\fIkey\fP Key for which the value has to be set\&. 
.br
\fIvalue\fP Value which has to be set\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
econf_err ECONF_SUCCESS or error code 
.RE
.PP

.SS "\fBeconf_err\fP econf_setFloatValue (\fBeconf_file\fP * kf, const char * group, const char * key, float value)"

.PP
Set float value for given group/key\&. 
.PP
\fBParameters:\fP
.RS 4
\fIkf\fP given/parsed data 
.br
\fIgroup\fP Desired group or NULL if there is no group defined\&. 
.br
\fIkey\fP Key for which the value has to be set\&. 
.br
\fIvalue\fP Value which has to be set\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
econf_err ECONF_SUCCESS or error code 
.RE
.PP

.SS "\fBeconf_err\fP econf_setDoubleValue (\fBeconf_file\fP * kf, const char * group, const char * key, double value)"

.PP
Set double value for given group/key\&. 
.PP
\fBParameters:\fP
.RS 4
\fIkf\fP given/parsed data 
.br
\fIgroup\fP Desired group or NULL if there is no group defined\&. 
.br
\fIkey\fP Key for which the value has to be set\&. 
.br
\fIvalue\fP Value which has to be set\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
econf_err ECONF_SUCCESS or error code 
.RE
.PP

.SS "\fBeconf_err\fP econf_setStringValue (\fBeconf_file\fP * kf, const char * group, const char * key, const char * value)"

.PP
Set string value for given group/key\&. 
.PP
\fBParameters:\fP
.RS 4
\fIkf\fP given/parsed data 
.br
\fIgroup\fP Desired group or NULL if there is no group defined\&. 
.br
\fIkey\fP Key for which the value has to be set\&. 
.br
\fIvalue\fP Value which has to be set\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
econf_err ECONF_SUCCESS or error code 
.RE
.PP

.SS "\fBeconf_err\fP econf_setBoolValue (\fBeconf_file\fP * kf, const char * group, const char * key, const char * value)"

.PP
Set bool value for given group/key\&. 
.PP
\fBParameters:\fP
.RS 4
\fIkf\fP given/parsed data 
.br
\fIgroup\fP Desired group or NULL if there is no group defined\&. 
.br
\fIkey\fP Key for which the value has to be set\&. 
.br
\fIvalue\fP Value which has to be set\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
econf_err ECONF_SUCCESS or error code 
.RE
.PP

.SS "const char* econf_errString (const \fBeconf_err\fP error)"

.PP
Convert an econf_err type to a string\&. 
.PP
\fBParameters:\fP
.RS 4
\fIerror\fP error enum 
.RE
.PP
\fBReturns:\fP
.RS 4
human readable string 
.RE
.PP

.SS "void econf_errLocation (char ** filename, uint64_t * line_nr)"

.PP
Info about where the error has happened\&. 
.PP
\fBParameters:\fP
.RS 4
\fIfilename\fP Path of the last scanned file\&. 
.br
\fIline_nr\fP Number of the last handled line\&. 
.RE
.PP

.SS "void econf_freeArray (char ** array)"

.PP
Free an array of type char** created by \fBeconf_getGroups()\fP or \fBeconf_getKeys()\fP\&. 
.PP
\fBParameters:\fP
.RS 4
\fIarray\fP array of strings 
.RE
.PP
\fBReturns:\fP
.RS 4
void 
.RE
.PP

.SS "void econf_freeFile (\fBeconf_file\fP * key_file)"

.PP
Free memory allocated by e\&.g\&. \fBeconf_readFile()\fP, \fBeconf_readDirs()\fP,\&.\&.\&.
.PP
\fBParameters:\fP
.RS 4
\fIkey_file\fP allocated data 
.RE
.PP
\fBReturns:\fP
.RS 4
void 
.RE
.PP

.SS "\fBeconf_err\fP econf_getExtValue (\fBeconf_file\fP * kf, const char * group, const char * key, \fBeconf_ext_value\fP ** result)"

.PP
Evaluating more information for given group/key\&. 
.PP
\fBParameters:\fP
.RS 4
\fIkf\fP given/parsed data 
.br
\fIgroup\fP Desired group or NULL if there is no group defined\&. 
.br
\fIkey\fP Key for which the value is requested\&. 
.br
\fIresult\fP A newly allocated struct or NULL in error case\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
econf_err ECONF_SUCCESS or error code 
.RE
.PP

.SS "void econf_freeExtValue (\fBeconf_ext_value\fP * to_free)"

.PP
Free an complete \fBeconf_ext_value\fP struct\&. 
.PP
\fBParameters:\fP
.RS 4
\fIto_free\fP struct which has to be freed 
.RE
.PP
\fBReturns:\fP
.RS 4
void 
.RE
.PP

.SH "SEE ALSO"
.PP 
econftool\&
